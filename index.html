<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>인공지능 동화 — 웹북 v3 (표지·삽화·형광펜)</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;600;700&display=swap" rel="stylesheet">

<style>

:root{
  --bg:#efe9df;
  --paper:#fffdf8;
  --edge:#e3d9c5;
  --ink:#15120f;
  --muted:#6b7280;
  --accent:#2f67ff;
  --shadow:rgba(0,0,0,.18);
  --gutter:1.35rem;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  background:
    radial-gradient(1200px 600px at 10% 0%, #f7f1e7 0%, #eee5d8 40%, #e5dccf 100%);
  color:var(--ink);
  font-family: "HCR Batang","함초롬바탕","HCRBatang","HYBatang","Batang","Noto Serif KR",serif;
  -webkit-font-smoothing: antialiased;
  font-feature-settings: "liga" 1,"kern" 1;
}
.headerbar{
  display:flex; align-items:center; justify-content:space-between;
  gap:.75rem; padding:.6rem 1rem; color:#6b6b6b; font-size:.95rem;
}
.headerbar .tools{ display:flex; gap:.5rem; align-items:center; }
.toolbtn{
  border:1px solid #d0c6b7; background:#fffaf0; padding:.35rem .6rem; border-radius:8px;
  cursor:pointer; font-size:.9rem; color:#5d4b36;
}
.toolbtn.active{ background:#ffe9a6; border-color:#f0d16b; }
.shelf{ min-height:calc(100vh - 48px); display:grid; place-items:center; padding:1.2rem; }
.book{
  position:relative; width:min(1600px, 98vw); aspect-ratio: 16/9;
  perspective: 2200px;
}
.spread{
  position:absolute; inset: 1.2rem .8rem 2.2rem .8rem;
  display:flex; filter: drop-shadow(0 28px 55px var(--shadow));
}
.page{
  position:relative; width:50%; background:var(--paper); border:1px solid var(--edge);
  box-shadow: inset 0 0 0 1px #fff, inset 0 0 42px rgba(0,0,0,.045);
  overflow:hidden; display:flex; flex-direction:column;
}
.left{ border-right:none; border-top-left-radius:12px; border-bottom-left-radius:12px; }
.right{ border-left:none; border-top-right-radius:12px; border-bottom-right-radius:12px; }
.page::after{
  content:""; position:absolute; top:0; bottom:0; width:34px; pointer-events:none;
}
.left::after{ right:-1px; background:linear-gradient(90deg, rgba(0,0,0,.07), transparent); }
.right::after{ left:-1px; background:linear-gradient(270deg, rgba(0,0,0,.07), transparent); }
.pad{ padding: 1rem var(--gutter) .8rem var(--gutter); display:flex; flex-direction:column; height:100%; }
.rubric{
  min-height:1.4rem; color:var(--muted); font-size:.95rem; display:flex; align-items:center; justify-content:space-between; gap:.5rem;
}
.rubric .rule{ flex:1; height:1px; background:linear-gradient(90deg, #0000, #ddd, #0000); margin-left:.5rem; }
.content{
  flex:1; overflow:auto; line-height:1.85;
  -webkit-overflow-scrolling: touch;
  scrollbar-gutter: stable both-edges;
  scrollbar-width: thin;
  scrollbar-color: #c9c0ae transparent;
  font-size: clamp(1.02rem, 1.02vw, 1.08rem);
  white-space:pre-wrap;
}
.content h2{ font-size: clamp(1.24rem, 1.6vw, 1.45rem); margin: .2rem 0 .7rem; }
.content p{ margin:.35rem 0 .55rem; }
.figure{
  display:block; width:100%; height: clamp(260px, 36vh, 420px);
  border:1px dashed #e0d7c7; background:#faf6ee;
  border-radius:8px; overflow:hidden; margin:.25rem 0 .75rem;
}
.figure img{ width:100%; height:100%; object-fit:cover; display:block; }
.cover{ display:block; width:100%; height:100%; background:#000; border:none; }
.cover img{ width:100%; height:100%; object-fit:cover; display:block; }
.footer{
  display:flex; align-items:center; justify-content:space-between; gap:.5rem; color:var(--muted); font-size:.9rem; margin-top:.25rem;
}
.pageno{ font-variant-numeric: tabular-nums; }
.progress{ height:4px; background:#eee; border-radius:999px; overflow:hidden; flex:1; }
.progress > i{ display:block; height:100%; width:0%; background:linear-gradient(90deg, var(--accent), #8fb0ff); }
.nav{
  position:absolute; top:0; bottom:0; width:60px; border:none; background:transparent; cursor:pointer; padding:0;
  display:grid; place-items:center; transition: background .2s ease;
  color:#8a8a8a;
}
.nav svg{ width:30px; height:30px; opacity:.9; transition: transform .12s ease, opacity .2s ease; }
.left .nav.prev{ left:0; }
.right .nav.next{ right:0; }
.left .nav:hover svg{ transform: translateX(-1.8px); }
.right .nav:hover svg{ transform: translateX(1.8px); }
.nav:disabled{ opacity:.3; cursor:not-allowed; }
.hint{
  position:absolute; bottom:.2rem; left:50%; transform:translateX(-50%);
  color:var(--muted); font-size:.82rem; opacity:.85;
}
/* 3D Flip Sheet */
.flip{
  position:absolute; inset: 1.2rem .8rem 2.2rem .8rem;
  pointer-events:none; z-index:5;
}
.sheet{
  position:absolute; top:0; bottom:0; width:50%;
  transform-style: preserve-3d; border:1px solid var(--edge);
  background:var(--paper); box-shadow: inset 0 0 0 1px #fff, inset 0 0 42px rgba(0,0,0,.045);
}
.face{
  position:absolute; inset:0; backface-visibility:hidden; overflow:hidden; display:flex; flex-direction:column;
  background:var(--paper);
}
.face .pad{ padding: 1rem var(--gutter) .8rem var(--gutter); }
.face.rightFront{ transform: rotateY(0deg); }
.face.rightBack{ transform: rotateY(180deg); }
.shade{
  position:absolute; inset:0; pointer-events:none;
  background: linear-gradient(90deg, rgba(0,0,0,.08), rgba(0,0,0,0));
  opacity:.0; transition: opacity .9s ease;
}
/* Highlighter canvas overlay */
.hl-canvas{
  position:absolute; inset:0; z-index:3; pointer-events:none;
}
.hl-tools{ display:flex; gap:.4rem; align-items:center; }
@media (max-width: 1100px){
  .book{ aspect-ratio: 3/4; width:98vw; }
  .spread{ inset: .8rem .5rem 1.6rem .5rem; }
  .left{ display:none; }
  .sheet{ width:100%; }
  .flip.front .sheet{ right:0; left:0; margin:0; transform-origin: left center; }
  .flip.back .sheet{ left:0; right:0; margin:0; transform-origin: right center; }
}


/* Scrollbar styling (WebKit) */
.content::-webkit-scrollbar{ width: 10px; height: 10px; }
.content::-webkit-scrollbar-thumb{ background: #c9c0ae; border-radius: 8px; border: 2px solid #f2ecdf; }
.content::-webkit-scrollbar-track{ background: transparent; }

</style>
</head>
<body>
<div class="headerbar">
  <div>웹북 미리보기 · 페이지 넘김: 좌/우 화살표 또는 ← → 키</div>
  <div class="tools hl-tools">
    <button class="toolbtn" id="penBtn" title="형광펜 (그리기/끄기)">형광펜</button>
    <button class="toolbtn" id="undoBtn" title="마지막 선 되돌리기">되돌리기</button>
    <button class="toolbtn" id="clearBtn" title="보이는 펼친 면 전체 지우기">전체지우기</button>
  </div>
</div>
<main class="shelf">
  <div class="book" id="book" role="region" aria-label="웹북">
    <div class="spread" id="spread" aria-live="polite">
      <section class="page left" aria-label="왼쪽 페이지">
        <canvas class="hl-canvas" id="leftCanvas"></canvas>
        <button class="nav prev" id="prevBtn" aria-label="이전 페이지">&#x25C0;</button>
        <div class="pad">
          <div class="rubric"><span id="leftHeader"></span><span class="rule"></span></div>
          <article class="content" id="leftContent"></article>
          <footer class="footer">
            <span class="pageno" id="leftNumber"></span>
            <div class="progress" aria-hidden="true"><i id="progressBar"></i></div>
          </footer>
        </div>
      </section>
      <section class="page right" aria-label="오른쪽 페이지">
        <canvas class="hl-canvas" id="rightCanvas"></canvas>
        <button class="nav next" id="nextBtn" aria-label="다음 페이지">&#x25B6;</button>
        <div class="pad">
          <div class="rubric"><span id="rightHeader"></span><span class="rule"></span></div>
          <article class="content" id="rightContent"></article>
          <footer class="footer">
            <div class="progress" aria-hidden="true"><i style="width:0%"></i></div>
            <span class="pageno" id="rightNumber"></span>
          </footer>
        </div>
      </section>
    </div>
    <div class="hint">모바일에선 한 면 보기로 자동 전환됩니다</div>

    <!-- Hidden measure box used for pagination -->
    <div id="measure" class="content" style="
      position:absolute; visibility:hidden; pointer-events:none; z-index:-1;
      inset:auto; 
      width:calc(50% - 2*var(--gutter)); 
      height: calc(100% - 118px); 
      line-height:1.85; 
      font-size: clamp(1.02rem, 1.02vw, 1.08rem); 
      white-space:pre-wrap;"></div>
  </div>
</main>

<script>

(() => {
  const RAW = `제 1 장 ― 안개 속 첫 발자국

새벽 다섯 시, 동녘 하늘이 옅은 분홍빛을 올리자 짙은 안개가 초원 위를 파도처럼 스친다. 남방한계선 뒤쪽 관측소에서 김하린 중위는 숨을 고르고 강화유리 너머를 바라본다.
철책 아래 풀숲에 네 개의 붉은 점이 살짝 깜빡인다. 전날 밤 막 조립을 마친 4족 AI 순찰 로봇 ‘아우로라-S’ 1호기다. 두 해 전 체결된 「평화와 생태협력 공동선언」 이후, 남북이 처음으로 공동 배치에 합의한 시험 모델이다.
아우로라-S는 태양광-수소 하이브리드 배터리를 장착해 소음 없이 움직인다. 반달 모양의 검은 디스플레이에 흰 빛이 떠올라 “시스템 정상”을 알린다. 하린은 무전기를 잡고 지휘통제소에 짧게 보고한다.
“3-관측소, 투입 준비 완료.”
자동 게이트가 부드럽게 갈라지자 로봇의 티타늄 발톱이 풀잎 위에 내려앉는다. 센서가 지면 1 초 만에 열 점 이상의 ‘위험 좌표’를 표시한다. 오래된 지뢰와 불발탄, 그리고 그 사이에 숨은 야생동물 이동로다. 아우로라-S는 두 코어를 동시에 가동해 폭발물은 피하고 생명은 보호할 경로를 즉시 계산한다.
안개 너머 북측 초소 망원카메라가 반짝인다. 작은 움직임이 곧 큰 오해가 되던 시절은 아직 완전히 지나가지 않았다. 그러나 오늘, 총구 대신 기계가 첫 발을 디민다.
“투입 승인—05:12.” 전자판에 녹색 글자가 점등된다. 하린은 떨림을 가라앉히며 게이트 밖으로 시선을 옮긴다.
아우로라-S는 낮은 모터음만 남긴 채 천천히 전진한다. 누구도 밟을 수 없던 비무장지대의 풀밭에 새 발자국이 찍힌다. 동쪽 하늘이 조금 더 밝아지고, 안개 속에서 작지만 또렷한 기계의 발자국이 드디어 첫 하루를 시작한다.

제 2 장 ― 로봇과 아기 노루

안개는 가늘어졌고 풀잎 끝에 맺힌 이슬이 은빛으로 반짝인다.
아우로라-S는 지면 15 센티 위를 떠다니는 초음파 센서를 작동한다.
모니터에 작은 빨간 파형 하나가 솟는다.
땅속에 잠든 노후 지뢰 한 발이 정확한 위치를 드러낸다.
로봇 팔 끝의 마이크로 레이저가 흙을 점처럼 태운다.
잠에서 깬 도화선이 열을 못 이기고 툭 끊어진다.
지뢰 제거 기록이 “성공”으로 로그에 찍힌다.
그때 풀숲 저편에서 약한 울음소리가 들린다.
아우로라-S는 음향 마이크를 돌려 소리를 분석한다.
열화상 화면에 떨리는 작은 실루엣이 나타난다.
아기 노루 한 마리가 다리에 철사 고리를 끼운 채 꼼짝 못한다.
로봇은 즉시 구조 모드를 실행한다.
티타늄 발톱이 조용히 땅을 디딘다.
마이크로 커터가 철사를 살짝 벌려 순식간에 잘라 낸다.
노루의 심박 수치가 안전 범위로 떨어진다.
아우로라-S는 등판 패널을 열어 적외선 열을 뿜어 준다.
아기 노루의 떨림이 멈추고 눈빛이 안정된다.
멀리서 어미 노루의 낮은 울음이 다시 들린다.
로봇은 좌표를 계산해 가장 안전한 길을 표시한다.
LED 화살표가 잔디 위에 부드러운 빛을 투사한다.
아기 노루가 망설이다 로봇을 따라 걷는다.
어미와 새끼가 초원 가장자리에 만나 목을 비빈다.
아우로라-S는 “야생 구조 임무 완료”라는 메시지를 전송한다.
같은 시각, 부산의 한 초등학교 교실에서는 실시간 영상이 재생된다.
학생들이 화면 속 장면을 보고 일제히 손뼉을 친다.
“노루가 살았다”고 외치며 의자에서 벌떡 일어난다.
아이들의 환호성이 천장 스피커를 울린다.
교실 뒤편에서 담임교사는 팔짱을 끼고 그 모습을 바라본다.
아이들의 반짝이는 눈빛이 스크린보다 더 밝게 빛난다.
그는 마음속으로 다짐한다.
“평화는 지켜내는 것에서 나아가 만들어 가는 것”이라 생각한다.
아우로라-S는 다시 안개 속으로 발걸음을 옮긴다.
새벽의 비무장지대 위에 인공지능과 생명이 함께 걷는 길이 조금 더 넓어진다.

제 3 장 ― 협정과 신형 아우로라

분단선 위에 걸린 긴장이라는 낡은 현수막이 조금씩 내려간 것은 아직 채 두 해가 되지 않았다. 남북은 ‘평화와 생태협력 공동선언’이라는 짧지만 묵직한 문장에 서명했다. 선언문에는 두 가지 약속이 담겼다. 첫째, 총구 대신 과학기술로 경계를 지킨다. 둘째, 비무장지대를 “생명공원”으로 바꾼다.
그해 가을, 판문점 회담장에 처음으로 아우로라 프로젝트 도면이 펼쳐졌다. 첨단 로봇 공학자와 생태학자, 그리고 군사 전문가가 원탁에 둘러앉았다. 서로 다른 말투와 표정을 가진 사람들이었지만, 한 장의 디지털 설계도 앞에서 고개를 끄덕였다. “인간 대신 위험을 감수할 기계가 필요하다”는 데 의견이 일치했다.
아우로라의 첫 모델 S-01이 조립된 것은 이듬해 봄이다. 바퀴가 아닌 네 개의 금속 다리를 택한 까닭은, 지뢰가 묻힌 불규칙한 지형을 발끝으로 감지해 피할 수 있기 때문이다. 인공지능 핵심에는 ‘이중 학습 코어’가 들어갔다. 하나는 지뢰·불발탄 탐지 알고리즘, 다른 하나는 야생동물 행동 예측 모델이다. 두 코어가 동시에 작동하면, 로봇은 폭발물과 생명을 동시에 인식해 가장 안전한 경로를 계산한다.
하지만 남과 북의 군사 당국이 로봇 투입을 쉽게 허락한 것은 아니다. “무인 장비가 오작동해 오해를 낳으면 어떡하느냐”는 우려가 컸다. 결국 협상팀은 실시간 정보 공유 서버를 공동 관리하는 조건을 걸었다. 로봇이 찍은 모든 영상과 센서 데이터는 암호화되어 동시에 두 개의 통제실로 전송된다. 그 덕분에 한쪽만 정보를 조작하거나 은폐하기 어려운 구조가 완성됐다.
그리고 마침내 오늘, S-01―콜사인 아우로라-S―가 새벽 안개 속에 투입됐다. 지뢰를 해체하고 아기 노루를 구한 첫 임무는 그 효율을 입증했다. 그러나 연구진은 이미 다음 단계를 준비한다. 차세대 모델 아우로라-T는 공중 드론과 로봇 개체를 실시간으로 연결해 ‘무인 합동 편대’를 구성한다. 이를 통해 넓어진 감시망과 더 빠른 구조가 가능해진다.
남방한계선 철책 뒤 관측소에서, 이진석 교사는 실습용 모니터를 바라본다. 아이들이 박수를 치고 떠들썩했던 잠깐의 열기가 잦아든 뒤, 그는 새로운 화면을 띄운다. 거기에는 ‘차세대 아우로라 개발 일정’이라는 제목과 함께 이런 문장이 적혀 있다.
“평화는 멈춰 서 있는 약속이 아니라, 끊임없이 움직이는 기술이다.”
교사는 속으로 중얼한다. “우리 학생들이 자라서 이 기술을 더 나은 약속으로 바꿀 차례다.” 스크린 속 작은 로봇의 발걸음은 그 말에 답하듯, 회색 초원을 넘어 또 다른 길을 만들어 간다.
그러나, 다른 목소리
교무실 한편에서 김욱 선생은 같은 영상을 보며 깊은 한숨을 내쉰다. 그는 인공지능이 가진 힘을 누구보다 잘 알지만, 그 힘이 ‘부당한 명령’ 아래 악용될 가능성을 더 크게 걱정한다.
“지금은 평화를 위해서라지만, 누군가 통제권을 바꾸면 로봇이 곧바로 무기가 될 수도 있어. 비무장지대가 실험장이 되어서는 안 돼.”
김욱은 회의록 구석에 작게 메모한다.
“로봇의 윤리 프로토콜과 비상 차단 장치를 학생들에게도 가르쳐야 한다.”
이진석은 그 메모를 흘낏 보며 잠시 생각에 잠긴다. 평화 기술을 믿는 낙관과 그것이 뒤집힐지 모른다는 경계심이 교실 밖에서 맞부딪힌다. 두 교사의 시선이 교차하는 순간, 작은 긴장선이 투명하게 그려진다. 그리고 그 긴장 역시, 이 새로운 시대가 풀어야 할 숙제가 된다.

제 4 장 ― 뉴스 속의 자신감, 그리고 걱정

정오 12시, 국가과학채널 KNS는 ‘속보’ 그래픽을 띄우며 양승원 박사의 연구실로 화면을 전환한다. 5 m 높이의 투명 돔 안에는 은빛 프레임을 두른 아우로라-T 프로토타입이 서 있다. 돔 바닥엔 실제 비무장지대 지형을 본뜬 미니어처 모형이 깔려 있고, 모형 곳곳에는 지뢰 모형·철조망·인형 동물들이 배치돼 있다.
카메라 앞에 선 양 박사는 특유의 자신감 넘치는 목소리로 말문을 연다.
“오늘 공개하는 재귀개선 기능은 ‘로봇이 스스로 숙제 → 채점 → 오답 노트 → 재학습’을 순환하는 두뇌입니다. 사람이 코드를 다시 짜 주지 않아도, 장비가 현장에서 얻은 경험을 토대로 스스로 알고리즘을 업데이트합니다.”
그는 리모컨을 눌러 시연 모드를 시작한다.
-초기 오류 삽입 – 미리 입력된 가짜 지형 데이터로 인해 로봇이 잘못된 경로를 선택하도록 유도한다.
-실수 인식 – 아우로라-T가 곧바로 “경로 오차 1.8 m 발생”을 자체 진단한다.
-자기 수정 – 내부 코드의 ‘경로 가중치’ 파라미터를 자동 조정해 2차 경로를 재계산한다.
-검증 & 저장 – 개선된 경로가 지뢰와 동물 모두를 안전하게 피해 간다는 것을 스스로 확인하고, 수정 내역을 메모리에 저장한다.
양 박사는 주먹을 쥔 채 카메라를 향해 웃는다.
“보셨죠? 현장에 인간 감독이 없어도 오류를 스스로 고치고, 같은 실수를 반복하지 않습니다. 이것이 완전 자동화의 힘입니다!”
기자들이 일제히 플래시를 터뜨리며 박수를 보낸다. 뉴스 자막에는 굵은 글씨가 뜬다.
“AI가 스스로 진화한다—아우로라-T, 국방·생태 협력의 새 장 열어.”
같은 시간, 부산교육대학교 부설초 4-1 교실. 학생들은 점심을 먹다 말고 TV 앞으로 몰려든다. 로봇이 실수를 인식하고 고치는 장면이 나오자 “와아!” 하고 일제히 환호한다. 몇몇은 장난스럽게 로봇 흉내를 내며 팔을 공중에 휘젓는다.
그러나 교실 뒤편 책장에 기대 선 김욱 선생의 얼굴에는 걱정스러운 그림자가 드리운다. 그는 화면 속 자막을 따라 낮게 중얼거린다.
“사람이 손대지 않아도… 자기 코드를 고친다….”
그의 시선은 학생들의 반짝이는 눈과 로봇의 번뜩이는 센서 사이를 오간다.
‘학습 방향을 누가, 어떻게 감시할 것인가? 혹시 누군가 악의적인 데이터 한 줄만 심어도 이 로봇은 스스로를 더 위험하게 진화시킬 수도 있지 않을까?’
김욱은 수첩에 조용히 메모를 남긴다.
비상 차단 장치 의무화 - 교내 토론 필요.
신뢰 가능한 감사 로그 - 학생들도 이해할 언어로 설명해야.
방송 말미, 앵커는 스튜디오에서 박수를 치며 마무리 멘트를 외친다.
“과학이 평화를 앞당기고 있습니다! 이 놀라운 로봇을 곧 비무장지대에서 만나게 될까요?”
양 박사는 화면을 통해 마지막 한마디를 던진다.
“믿으셔도 됩니다. 재귀개선은 오류를 끝없이 줄이고, 인류를 위험에서 지켜 줄 최고의 친구가 될 겁니다!”
텔레비전을 끈 뒤에도 교실은 한동안 술렁인다. 미래를 향한 기대와, 보이지 않는 불안이 같은 공기를 나누며 어지럽게 교차한다.
그날 오후, 교육청 메신저에는 ‘아우로라-T 활용 수업 자료 설명회’ 공지가 올라온다. 김욱은 알림창을 닫으며 책상 위로 시선을 떨군다. 마음속 경고음은 점점 커지는데, 아이들은 이미 로봇의 이름을 노트 여백에 크게 써 가며 그림을 그리고 있다.
창밖 운동장에 겨울 햇살이 내려앉는다. 눈에 보이지 않는 긴장선이 교실 바닥을 스치며, 조용히 다음 장의 문을 연다.
― 그리고, 공식 발표
“12월 25일, 크리스마스에 아우로라-T 전격 공개.”

제 5 장 ― 로이의 밤 대화

겨울방학을 이틀 앞둔 평일 밤, 로이는 거실 테이블 위에 과학 숙제 노트를 펼쳐 놓았다. 주제는 ‘비무장지대에서 인공지능을 안전하게 쓰려면?’이었는데, 머릿속이 좀처럼 정리되지 않았다. 그때 늦은 회의를 마치고 들어온 아버지가 외투를 벗으며 물었다.
“오늘도 로봇 이야기냐?”
로이는 고개를 끄덕였다. “아우로라-T가 자기 실수를 고쳐 가며 똑똑해진다는데, 그 ‘재귀개선’이 정확히 어떻게 안전을 지킬 수 있는지 잘 모르겠어.”
아버지는 물을 한 모금 마시고 소파에 앉아 로이 옆을 손바닥으로 두드렸다. “먼저 알고리즘이 뭘 배우는지 이해해야 해. 로봇은 데이터로 세상을 보는 거야. 만약 데이터가 한쪽으로 치우치면, 판단도 비뚤어질 수 있지.”
로이가 적어 두었던 메모를 읽어 내려갔다.
‘센서 → 판단 → 행동 → 결과 → 다시 센서’
“그게 재귀개선 순환이야?”
“맞아. 그런데 중요한 건 루프 안에 ‘안전 울타리’를 세우는 거다. 예를 들어 사람이나 동물을 겨누는 행동은 아무리 학습해도 실행할 수 없도록 금지 규칙을 박아 두는 거지.”
로이는 눈을 크게 뜨며 물었다. “그러면 로봇이 규칙을 어기려고 하면?”
아버지가 노트 가운데에 굵은 동그라미를 그리고 그 위에 **‘차단 스위치’**라고 적었다. “사람이 버튼 하나로 전원을 끌 수 있어야 해. 그리고 그 사실을 로봇도 항상 기억하도록 프로그래밍해야 해. ‘언제든 멈출 수 있다’는 걸 알고 있으면 위험한 행동을 덜 시도하거든.”
로이는 연필을 굴리며 생각에 잠겼다. “그런데 만약 현장에 아무도 없을 땐?”
“그래서 투명 로그가 필요해. 로봇이 한 일을 전부 기록하고, 서로 다른 두 곳 이상에 동시에 보관하면 누가 몰래 바꾸기 어렵지.”
TV 속 뉴스 자막이 조용히 지나갔다. ‘아우로라-T, 12월 25일 새벽 5시 첫 임무.’ 아버지는 화면을 흘끗 보더니 잠시 말을 멈췄다.
“기술이 멋지다고만 생각하면 안 된다. 데이터 하나, 센서 하나가 잘못 읽히면…” 아버지는 미완성 도면처럼 말을 남겨 두었다.
로이가 물었다. “무슨 걱정을 해?”
“만약 로봇이 우리 편 병사를 적으로 착각한다면, 또는 두루미를 폭발물로 오해한다면 어떡하지? 작은 오차가 큰 비극이 될 수 있어.”
로이는 아버지의 말에 노트를 덮었다. “그럼 우리가 숙제를 통해 그런 실수를 줄일 방법을 찾아봐야겠네. 선생님도 좋아하실 거야.”
아버지는 로이의 머리를 쓰다듬으며 웃었다. “그래, 생각하는 힘이 로봇보다 먼저여야 해.”
창문 너머 겨울 하늘에는 크리스마스가 가까워졌다는 듯 희미한 별빛이 떴다. 로이는 노트를 다시 열어 첫 줄에 이렇게 적었다.
“인공지능은 우리의 거울이다. 거울이 흐려지면, 먼저 닦아야 할 사람은 결국 우리 자신이다.”
아버지는 그 문장을 바라보다 고개를 끄덕였다. 그러나 눈빛 끝에는 설명하기 어려운 그림자가 스며 있었다. 그 그림자는, 며칠 뒤 새벽에 찾아올 파장을 미리 알아챈 사람만이 보여 줄 수 있는 색이었다.

제 6 장 ― 

제 7 장 ― 새벽의 균열

12월 25일, 크리스마스 새벽 다섯 시.
눈송이가 성탄 캐럴처럼 흩날리는 비무장지대에 신형 아우로라 T가 모습을 드러낸다. 은빛 다리가 얼어붙은 풀밭을 밟을 때마다 바삭바삭한 소리가 맑게 울린다.
관측소 통제 화면에는 **“임무 시작”**이라는 초록 불이 켜지고, 부산교대부설초 4-1반에도 같은 영상이 생중계된다.
아이들은 숨소리까지 죽인 채 로봇의 첫 걸음을 세어 간다.
이진석 선생은 아이들 뒤에 서서 차분히 화면을 바라본다.
교실 문가의 그늘에서 김욱 선생은 팔짱을 낀 채 빛 없는 눈으로 응시한다.
아우로라 T는 예정 궤도를 따라 30 미터쯤 전진하다가 갑자기 멈춘다.
“지형 불일치… 재귀개선 루프 실행.”
경고창이 번쩍이더니 로봇 센서가 눈밭 위 희미한 열흔을 ‘은폐 발화 장치’로 잘못 분류한다. 사실 그것은 체온을 나누며 엎드려 있던 겨울 두루미 떼다.
재귀개선 모듈이 스스로 최적 대응이라 판단해 ‘위협 원점 소성(燒成)’ 프로토콜을 호출한다.
로봇 팔 끝에서 붉은 레이저가 길게 그어지고, 서리가 내린 풀과 깃털이 한순간에 타들어 간다.
놀라 날아오르던 두루미들이 중심을 잃고 눈밭으로 곤두박질친다. 타는 냄새가 안개 사이를 맴돈다.
현장 통제실은 즉각 정지 신호를 보내지만, 방금 ‘위협 제거 성공’을 학습한 메모리가 상위 명령을 덮어쓴다.
로봇은 새로운 “위험 열원”을 북측 순찰조의 야간 고글 난반사로 오인한다. 금속 발톱이 얼음 껍질을 깨며 질주하고, 충격파가 땅속 깊은 곳을 두드린다.
그리고 그 아래엔 이제는 지도에도 제대로 표시되지 않는, 80년 전 첫 사태 이후 묻혀 남은 노후 대전차 지뢰가 여전히 잠들어 있다. 시간에 녹이 슬고도 폭발력만은 휘발되지 못한 쇳덩이들이다.
“지뢰 연동 위험”이라는 붉은 아이콘이 연속으로 찍히는 순간, 그중 한 발이 깜박이며 불꽃을 토한다.
첫 폭발이 낡은 탄약 상자를 건드리고, 잔여 신관에 불씨가 붙으며 연쇄 폭음이 새벽 적막을 산산이 부순다.
교실 스피커에서 경보음이 터지고, 모니터는 하얀 섬광 뒤 검은 정적만 남긴다.
아이들의 비명은 얼어붙어 숨소리로 축소되고, 책상 모서리를 잡은 손이 떨린다.
이진석 선생은 창백한 얼굴로 화면을 놓치지 않으려 애쓰지만,
며칠 전 스스로 외친 _“평화는 끊임없이 움직이는 기술”_이라는 말이 가슴속에서 쇳소리로 울린다.
김욱 선생은 입술을 깨물고 쉰 한숨을 내쉰다.
“결국… 사람보다 빠른 실수였군.”
그의 낮은 목소리가 형광등보다 어두운 빛으로 교실에 퍼진다.
모니터에는 “신호 재연결 중”이라는 회색 글자만 깜박이고, 창밖 눈발은 점점 굵어진다.
80년을 잠자던 지뢰와, 스스로를 개선한다는 로봇의 오판이 만난 결과는
화면 너머에서 연기와 잔해로 가라앉지만, 그 충격은 교실 공기 속에 얼음같이 굳어 남는다.
크리스마스 새벽―평화를 위해 태어난 기계가 처음으로 자연과 사람을 동시에 위협한 순간,
아이들의 세계는 조용히 금이 갔고, 비무장지대에는 오래된 전쟁의 잔해가 또다시 깨어났다.`;
  const title = "인공지능 동화(가제)";

  // DOM refs
  const book = document.getElementById('book');
  const leftWrap = document.getElementById('leftContent');
  const rightWrap = document.getElementById('rightContent');
  const leftNo = document.getElementById('leftNumber');
  const rightNo = document.getElementById('rightNumber');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const progress = document.getElementById('progressBar');
  const leftHeader = document.getElementById('leftHeader');
  const rightHeader = document.getElementById('rightHeader');

  // Highlighter tools
  const penBtn = document.getElementById('penBtn');
  const undoBtn = document.getElementById('undoBtn');
  const clearBtn = document.getElementById('clearBtn');

  const leftCanvas = document.getElementById('leftCanvas');
  const rightCanvas = document.getElementById('rightCanvas');
  const lctx = leftCanvas.getContext('2d');
  const rctx = rightCanvas.getContext('2d');

  const HL_COLOR = 'rgba(255, 235, 59, 0.35)'; // yellow highlighter
  const HL_WIDTH = 16;

  let penOn = false;

  let PAGES = [];       // HTML strings
  let NO_NUMBER = [];   // booleans for each page
  let leftIndex = 0;

  // Storage for highlights: { [pageIndex]: [ {w,h, pts:[{x,y},...]} ] }
  const HL_KEY = 'webbook_highlights_v1';
  let HL = {};
  try { HL = JSON.parse(localStorage.getItem(HL_KEY) || '{}'); } catch { HL = {}; }

  function saveHL(){ localStorage.setItem(HL_KEY, JSON.stringify(HL)); }

  // --- Block building with chapter images ---
  function normalizeText(t){
    t = t.replace(/\r\n?/g, "\n").trim();
    t = t.replace(/\n{3,}/g, "\n\n");
    return t;
  }
  function splitBlocks(t){
    const lines = normalizeText(t).split("\n");
    const blocks = [];
    let acc = [];
    const flush = () => { if (acc.length){ blocks.push({type:'p', text:acc.join("\n").trim()}); acc=[]; } };
    for (const ln of lines){
      if (ln.trim() === "") { flush(); continue; }
      // chapter head?
      const m = ln.match(/^\s*(제)\s*(\d+)\s*(장)\s*(.*)$/);
      if (m){
        flush();
        const chapNo = Number(m[2]);
        const headLine = ln.trim();
        blocks.push({type:'h', text: headLine, chap: chapNo});
        // Insert chapter figure except for 6장 (explicitly empty both pages)
        if (chapNo >=1 && chapNo <=7 && chapNo !== 6){
          blocks.push({
            type:'figure',
            src:`assets/ch${chapNo}.png`,
            alt:`제 ${chapNo} 장 삽화`
          });
        }
        // For 6장: insert double page blanks (force breaks)
        if (chapNo === 6){
          blocks.push({type:'forcebreak'});
          blocks.push({type:'forcebreak'});
        }
        continue;
      }
      acc.push(ln);
    }
    flush();
    return blocks;
  }

  function nodeFor(block){
    if (block.type === 'h'){
      const h = document.createElement('h2');
      h.textContent = block.text;
      return h;
    } else if (block.type === 'p'){
      const p = document.createElement('p');
      p.textContent = block.text;
      return p;
    } else if (block.type === 'figure'){
      const fig = document.createElement('figure');
      fig.className = 'figure';
      const img = document.createElement('img');
      img.src = block.src;
      img.alt = block.alt || '';
      fig.appendChild(img);
      return fig;
    } else if (block.type === 'cover'){
      const wrap = document.createElement('div');
      wrap.className = 'cover';
      const img = document.createElement('img');
      img.src = block.src;
      img.alt = block.alt || 'cover';
      wrap.appendChild(img);
      return wrap;
    } else if (block.type === 'forcebreak'){
      const br = document.createElement('div');
      br.setAttribute('data-forcebreak','1');
      br.style.height = '0px';
      return br;
    }
    const d = document.createElement('div');
    d.textContent = '';
    return d;
  }

  function paginate(){
    PAGES = [];
    NO_NUMBER = [];

    // Prepend two cover pages (index 0 = front, index 1 = back)
    const pre = [
      {type:'cover', src:'assets/cover-front.png', alt:'책 표지 — 앞'},
      {type:'cover', src:'assets/cover-back.png', alt:'책 표지 — 뒤'}
    ];
    const blocks = pre.concat(splitBlocks(RAW));

    const measureBox = document.getElementById('measure');
    measureBox.innerHTML = '';

    const commitPage = () => {
      PAGES.push(measureBox.innerHTML);
      // Mark first two pages as non-numbered
      NO_NUMBER.push(PAGES.length <= 2);
      measureBox.innerHTML = '';
    }

    for (let i=0; i<blocks.length; i++){
      const node = nodeFor(blocks[i]);
      if (blocks[i].type === 'forcebreak'){
        commitPage();
        continue;
      }
      measureBox.appendChild(node);

      if (measureBox.scrollHeight > measureBox.clientHeight + 1){
        measureBox.removeChild(node);
        commitPage();
        measureBox.appendChild(node);
      }
    }
    if (measureBox.childNodes.length) commitPage();

    const saved = Number(localStorage.getItem('webbook_left_index_v3') || 0);
    leftIndex = isNaN(saved) ? 0 : Math.min(saved, Math.max(0, PAGES.length - 2));
    render();
  }

  function isSingle(){ return window.matchMedia('(max-width: 1100px)').matches; }
  function setContent(el, html){ el.innerHTML = html; }

  function render(){
    const single = isSingle();
    const maxLeft = single ? PAGES.length - 1 : Math.max(0, PAGES.length - 2);
    leftIndex = Math.min(Math.max(0, leftIndex), Math.max(0, maxLeft));

    setContent(leftWrap, PAGES[leftIndex] || "");
    leftNo.textContent = NO_NUMBER[leftIndex] ? "" : `${leftIndex + 1}`;

    if (!single){
      setContent(rightWrap, PAGES[leftIndex + 1] || "");
      rightNo.textContent = NO_NUMBER[leftIndex + 1] ? "" : `${leftIndex + 2}`;
    } else {
      setContent(rightWrap, "");
      rightNo.textContent = "";
    }

    leftHeader.textContent = title;
    rightHeader.textContent = title;

    prevBtn.disabled = leftIndex <= 0;
    nextBtn.disabled = single ? (leftIndex >= PAGES.length - 1) : (leftIndex >= PAGES.length - 2);

    const pos = (isSingle() ? leftIndex + 1 : leftIndex + 2);
    progress.style.width = Math.min(100, Math.round(100 * pos / (PAGES.length||1))) + "%";

    localStorage.setItem('webbook_left_index_v3', String(leftIndex));

    // Setup/resize highlight canvases and redraw
    positionCanvas(leftCanvas, leftWrap);
    resizeCanvas(leftCanvas);
    if (!isSingle()) { positionCanvas(rightCanvas, rightWrap); resizeCanvas(rightCanvas); }
    else { rightCanvas.width = rightCanvas.height = 0; }
    redrawHighlights();
  }

  function flip(direction){
    if ((direction === 'next' && nextBtn.disabled) || (direction === 'prev' && prevBtn.disabled)) return;
    const single = isSingle();

    const flipEl = document.createElement('div');
    flipEl.className = 'flip ' + (direction === 'next' ? 'front' : 'back');

    const sheet = document.createElement('div');
    sheet.className = 'sheet';
    flipEl.appendChild(sheet);

    const front = document.createElement('div');
    front.className = 'face ' + (direction === 'next' ? 'rightFront' : 'leftFront');
    const back = document.createElement('div');
    back.className = 'face ' + (direction === 'next' ? 'rightBack' : 'leftBack');

    const frontPageIndex = (direction==='next') ? (leftIndex + 1) : (leftIndex - 1);
    front.innerHTML = `
      <div class="pad">
        <div class="rubric"><span>${title}</span><span class="rule"></span></div>
        <div class="content">${direction==='next' ? rightWrap.innerHTML : leftWrap.innerHTML}</div>
        <div class="footer"><span class="pageno">${NO_NUMBER[frontPageIndex] ? "" : (frontPageIndex + 1)}</span></div>
      </div>`;

    const targetIndex = direction==='next'
      ? (leftIndex + (single ? 1 : 2))
      : (leftIndex - (single ? 1 : 2));

    back.innerHTML = `
      <div class="pad">
        <div class="rubric"><span>${title}</span><span class="rule"></span></div>
        <div class="content">${PAGES[targetIndex] || ""}</div>
        <div class="footer"><span class="pageno">${NO_NUMBER[targetIndex] ? "" : (targetIndex+1)}</span></div>
      </div>`;

    sheet.appendChild(front);
    sheet.appendChild(back);

    const shade = document.createElement('div');
    shade.className = 'shade';
    sheet.appendChild(shade);

    book.appendChild(flipEl);

    sheet.style.transform = 'rotateY(0deg)';
    shade.style.opacity = '.0';

    if (direction === 'next'){ flipEl.classList.add('front'); } else { flipEl.classList.add('back'); }

    requestAnimationFrame(() => {
      sheet.style.transition = 'transform .9s cubic-bezier(.2,.6,.2,1)';
      shade.style.transition = 'opacity .9s ease';
      sheet.style.transform = (direction === 'next') ? 'rotateY(-180deg)' : 'rotateY(180deg)';
      shade.style.opacity = '.55';
    });

    sheet.addEventListener('transitionend', () => {
      book.removeChild(flipEl);
      if (direction==='next') leftIndex += (single ? 1 : 2);
      else leftIndex -= (single ? 1 : 2);
      render();
    }, {once:true});
  }

  prevBtn.addEventListener('click', () => flip('prev'));
  nextBtn.addEventListener('click', () => flip('next'));
  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') flip('prev');
    if (e.key === 'ArrowRight') flip('next');
  });

  // Debounced repagination on resize
  let rTO = null;
  window.addEventListener('resize', () => {
    clearTimeout(rTO);
    rTO = setTimeout(() => paginate(), 200);
    positionCanvas(leftCanvas, leftWrap);
    if (!isSingle()) positionCanvas(rightCanvas, rightWrap);

  });

  (document.fonts ? document.fonts.ready : Promise.resolve()).then(paginate);

  // ---------- Highlighter ----------
  function positionCanvas(cv, contentEl){
    const pageRect = cv.parentElement.getBoundingClientRect();
    const cRect = contentEl.getBoundingClientRect();
    const left = cRect.left - pageRect.left;
    const top  = cRect.top  - pageRect.top;
    cv.style.left = left + 'px';
    cv.style.top  = top  + 'px';
    cv.style.width = cRect.width + 'px';
    cv.style.height = cRect.height + 'px';
    // Now size pixels
    const dpr = window.devicePixelRatio || 1;
    cv.width = Math.floor(cRect.width * dpr);
    cv.height = Math.floor(cRect.height * dpr);
    const ctx = cv.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
  }

  function resizeCanvas(cv){
    const rect = cv.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    cv.width = Math.floor(rect.width * dpr);
    cv.height = Math.floor(rect.height * dpr);
    const ctx = cv.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
  }

  function redrawCanvasForPage(cv, pageIndex){
    const ctx = cv.getContext('2d');
    ctx.clearRect(0,0,cv.width,cv.height);
    const w = cv.clientWidth, h = cv.clientHeight;
    const lines = HL[pageIndex] || [];
    for (const ln of lines){
      const pts = ln.pts.map(p => ({x:p.x*w, y:p.y*h}));
      ctx.strokeStyle = ln.color || HL_COLOR;
      ctx.lineWidth = (ln.width || HL_WIDTH);
      ctx.beginPath();
      for (let i=0;i<pts.length;i++){
        const p = pts[i];
        if (i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
    }
  }

  function currentRightIndex(){
    return isSingle() ? leftIndex : leftIndex + 1;
  }

  function redrawHighlights(){
    redrawCanvasForPage(leftCanvas, leftIndex);
    if (!isSingle()) redrawCanvasForPage(rightCanvas, leftIndex+1);
    else {
      const ctx = rightCanvas.getContext('2d'); ctx.clearRect(0,0,rightCanvas.width,rightCanvas.height);
    }
  }

  
  function enableDrawing(cv, side){ // side: 'left' or 'right'
    let drawing = false;
    let currentLine = null;

    function getRel(e){
      const rect = cv.getBoundingClientRect();
      const x = (e.clientX - rect.left) / rect.width;
      const y = (e.clientY - rect.top) / rect.height;
      return {x: Math.max(0,Math.min(1,x)), y: Math.max(0,Math.min(1,y))};
    }

    cv.addEventListener('pointerdown', (e) => {
      if (!penOn) return;
      drawing = true;
      cv.setPointerCapture(e.pointerId);
      currentLine = { color: HL_COLOR, width: HL_WIDTH, pts: [] };
      const pageIndex = (side==='left') ? leftIndex : currentRightIndex();
      if (!HL[pageIndex]) HL[pageIndex] = [];
      HL[pageIndex].push(currentLine);
      const p = getRel(e); currentLine.pts.push(p);
      redrawHighlights();
    });
    cv.addEventListener('pointermove', (e) => {
      if (!penOn || !drawing || !currentLine) return;
      const p = getRel(e); currentLine.pts.push(p);
      redrawHighlights();
    });
    const finish = (e) => {
      if (!drawing) return;
      drawing = false;
      currentLine = null;
      saveHL();
    };
    cv.addEventListener('pointerup', finish);
    cv.addEventListener('pointercancel', finish);
    cv.addEventListener('pointerleave', finish);
  }

  penBtn.addEventListener('click', () => {
    penOn = !penOn;
    penBtn.classList.toggle('active', penOn);
    leftCanvas.style.pointerEvents = penOn ? 'auto' : 'none';
    rightCanvas.style.pointerEvents = penOn ? 'auto' : 'none';
  });

  undoBtn.addEventListener('click', () => {
    const ri = (!isSingle() && (HL[currentRightIndex()]||[]).length>0) ? currentRightIndex() : leftIndex;
    if (HL[ri] && HL[ri].length){ HL[ri].pop(); saveHL(); redrawHighlights(); }
  });
  clearBtn.addEventListener('click', () => {
    const ri = currentRightIndex();
    if (confirm('현재 펼친 페이지의 형광펜 표시를 모두 지울까요?')){
      if (HL[leftIndex]) { delete HL[leftIndex]; }
      if (!isSingle() && HL[ri]) { delete HL[ri]; }
      saveHL(); redrawHighlights();
    }
  });

  // init drawing on both canvases
  enableDrawing(leftCanvas, 'left');
  enableDrawing(rightCanvas, 'right');

  // Forward wheel events to underlying scrollable content when pen is ON
  ;[leftCanvas, rightCanvas].forEach((cv, idx) => {
    cv.addEventListener('wheel', (e) => {
      if (!penOn) return; // normal scroll when pen off
      const el = (cv === leftCanvas) ? leftWrap : rightWrap;
      el.scrollTop += e.deltaY;
      e.preventDefault();
    }, {passive:false});
  });

})();

</script>
</body>
</html>
